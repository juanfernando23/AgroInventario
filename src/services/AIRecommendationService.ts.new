import OpenAI from 'openai';

// Interfaz para las recomendaciones
export interface AIRecommendation {
  date: string;
  summary: string;
  recommendations: string[];
  observaciones: string;  // Cambiado de "insights" a "observaciones"
}

class AIRecommendationService {
  private openai: OpenAI;
  private static STORAGE_KEY = 'ai_recommendation_cache';
  
  constructor() {
    // Inicializar el cliente de OpenAI con la clave de API
    this.openai = new OpenAI({
      apiKey: import.meta.env.VITE_OPENAI_API_KEY, // Asegúrate de tener esta variable en tu .env
      dangerouslyAllowBrowser: true // Solo para desarrollo, en producción usa el backend
    });
  }

  /**
   * Obtiene el resumen de inventario para hoy
   * @param inventoryData Datos del inventario para analizar
   * @returns La recomendación generada o almacenada en caché
   */
  async getDailyRecommendation(inventoryData: any): Promise<AIRecommendation> {
    // Comprobar si ya tenemos una recomendación para hoy
    const cachedRecommendation = this.getTodaysCachedRecommendation();
    if (cachedRecommendation) {
      return cachedRecommendation;
    }

    // Si no hay recomendación en caché, generar una nueva
    return await this.generateRecommendation(inventoryData);
  }

  /**
   * Generar una nueva recomendación a pedido
   * @param inventoryData Datos actuales del inventario
   * @returns Una nueva recomendación
   */
  async generateOnDemandRecommendation(inventoryData: any): Promise<AIRecommendation> {
    return await this.generateRecommendation(inventoryData, false);
  }

  /**
   * Genera una recomendación usando la API de OpenAI
   * @param inventoryData Datos del inventario
   * @param shouldCache Si se debe almacenar en caché
   * @returns La recomendación generada
   */
  private async generateRecommendation(inventoryData: any, shouldCache = true): Promise<AIRecommendation> {
    try {
      const formattedDate = new Date().toLocaleDateString('es-ES', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });

      const prompt = this.createPrompt(inventoryData);
      
      const response = await this.openai.chat.completions.create({
        model: "gpt-4.1-nano", // Usando el modelo más económico similar a gpt-4.1 nano
        messages: [
          {
            role: "system",
            content: "Eres un asistente especializado en análisis de inventario agrícola. Tu tarea es proporcionar un resumen conciso, recomendaciones accionables y observaciones detalladas basadas en los datos de inventario proporcionados. Estructura tu respuesta en formato JSON con campos para summary, recommendations (array) e insights."
          },
          {
            role: "user",
            content: prompt
          }
        ],
        response_format: { type: "json_object" }
      });

      // Extraer y parsear la respuesta
      const aiResponse = JSON.parse(response.choices[0].message.content || '{}');
      
      const recommendation: AIRecommendation = {
        date: formattedDate,
        summary: aiResponse.summary || "No se pudo generar un resumen",
        recommendations: aiResponse.recommendations || ["No hay recomendaciones disponibles"],
        observaciones: aiResponse.insights || "No se pudieron generar observaciones detalladas"
      };

      // Guardar en caché si es necesario
      if (shouldCache) {
        this.cacheRecommendation(recommendation);
      }

      return recommendation;
    } catch (error) {
      console.error("Error al generar recomendaciones:", error);
      
      // Devolver una recomendación de error
      return {
        date: new Date().toLocaleDateString('es-ES'),
        summary: "Error al generar recomendaciones",
        recommendations: ["Verifica tu conexión a internet", "Comprueba la configuración de la API de OpenAI"],
        observaciones: "No se pudieron obtener observaciones detalladas debido a un error de comunicación"
      };
    }
  }

  /**
   * Crea el prompt para la API de OpenAI
   */
  private createPrompt(inventoryData: any): string {
    return `
      Analiza los siguientes datos de inventario agrícola y proporciona:
      1. Un resumen conciso del estado actual del inventario
      2. 3-5 recomendaciones accionables para optimizar el inventario
      3. Observaciones detalladas sobre tendencias, productos críticos o oportunidades

      DATOS DE INVENTARIO:
      ${JSON.stringify(inventoryData, null, 2)}
      
      Responde únicamente con un objeto JSON que tenga las propiedades: summary, recommendations (array) e insights.
    `;
  }

  /**
   * Almacena una recomendación en el almacenamiento local
   */
  private cacheRecommendation(recommendation: AIRecommendation): void {
    const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
    
    // Obtener recomendaciones existentes
    const existingCache = localStorage.getItem(AIRecommendationService.STORAGE_KEY);
    const cache = existingCache ? JSON.parse(existingCache) : {};
    
    // Guardar la recomendación de hoy
    cache[today] = recommendation;
    
    // Guardar en localStorage
    localStorage.setItem(AIRecommendationService.STORAGE_KEY, JSON.stringify(cache));
  }

  /**
   * Obtiene la recomendación almacenada para hoy, si existe
   */
  private getTodaysCachedRecommendation(): AIRecommendation | null {
    const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
    
    try {
      const cache = JSON.parse(localStorage.getItem(AIRecommendationService.STORAGE_KEY) || '{}');
      return cache[today] || null;
    } catch (error) {
      console.error("Error al recuperar caché de recomendaciones:", error);
      return null;
    }
  }
}

export default new AIRecommendationService();
